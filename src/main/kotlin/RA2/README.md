## 🧩 **INTERFACES**

### 🔹 Abstract Members

These are **declarations without implementations**. Classes that implement the interface must define them.

```kotlin
interface Animal {
fun makeSound() // abstract
}

class Dog : Animal {
override fun makeSound() = println("Woof!")
}
```

---

### 🔹 Members with Default Implementation

An interface can have **methods implemented** (by default).

```kotlin
interface Animal {
fun sleep() {
println("Zzz...")
}
fun makeSound()
}

class Cat : Animal {
override fun makeSound() = println("Meow!")
}
```

> `Cat` directly inherits the implementation of `sleep()`.

---

### 🔹 Interface Implementation

A class can **implement multiple interfaces** at once.

```kotlin
interface A { fun foo() = println("A") }
interface B { fun foo() = println("B") }

class C : A, B {
override fun foo() {
super<A>.foo() // choose which one to call
super<B>.foo()
}
}
```

---

### 🔹 Sealed Interfaces

Sealed interfaces limit which classes can implement them (only within the same file).

```kotlin
sealed interface Result
class Success(val data: String) : Result
class Error(val message: String) : Result
```

> Very useful for handling states in `when` without needing `else`.

---

## 🏗️ **CLASSES**

### 🔹 Primary constructor and `init` block

The **primary constructor** is defined along with the name, and `init` is executed when the object is created.

```kotlin
class Person(val name: String, val age: Int) {
init {
println("Creating person: $name, $age years")
}
}
```

---

### 🔹 Secondary constructors

They are used for **alternative initializations**.

```kotlin
class Person(val name: String) {
var age: Int = 0

constructor(name: String, age: Int) : this(name) {
this.age = age
}
}
```

---

### 🔹 Visibility Modifiers

They control **where members or classes can be accessed**:

- `public` (default)

- `internal` (only within the same module)

- `protected` (only in subclasses)

- `private` (only within the class)

```kotlin
class Example {
private val secret = "Hidden"
protected fun show() = println(secret)
}
```

---

## 💡 **PROPERTIES**

### 🔹 Access to the backing field (`field`)

Used within Custom `getter` or `setter`.

```kotlin
class Counter {
var value: Int = 0
set(new) {
if (new >= 0) field = new // field = backing field
}
}
```

---

### 🔹 Change visibility of the getter or setter

You can **limit access** to the `set` or `get`.

```kotlin
class User {
var name: String = "Unknown"
private set // Can only be read externally, not modified
}
```

---

### 🔹 Abstract Properties

Declared in interfaces or abstract classes, with no implementation.

```kotlin
interface Shape {
val area: Double
}

class Circle(val radius: Double) : Shape {
override val area get() = Math.PI * radius * radius
}
```

---

### 🔹 Extension Properties

They allow **adding properties to existing classes** (they do not store actual state).

```kotlin
val String.vowels: Int
get() = count { it.lowercaseChar() in "aeiou" }

println("Kotlin".vowels) // 2
```

---

## 🧬 **INHERITANCE**

### 🔹 `open`, `final`, `abstract`

- `open`: can be inherited or overridden.

- `final`: cannot be inherited or overridden.

- `abstract`: must be implemented in subclasses.

```kotlin
open class Animal {
open fun sound() = println("Noise")
}

class Dog : Animal() {
override fun sound() = println("Woof!")
}
```

---

### 🔹 Call to the base (primary) constructor

```kotlin
open class Person(val name: String)
class Student(name: String, val grade: String) : Person(name)
```

---

### 🔹 Call to the base (secondary) constructor

```kotlin
open class Person(val name: String)
class Teacher : Person {
constructor(name: String, subject: String) : super(name)
}
```

---

### 🔹 Sealed classes

They control which subclasses can exist (in the same file).

```kotlin
sealed class Result
class Success(val data: String) : Result()
class Error(val msg: String) : Result()
```

---

## 🧾 **DATA CLASSES (`data class`)**

### 🔹 Autogenerated Methods

`data class` generates `toString()`, `equals()`, `hashCode()`, and `copy()` automatically.

```kotlin
data class Person(val name: String, val age: Int)

val p1 = Person("Ana", 30)
println(p1) // Person(name=Ana, age=30)
```

---

### 🔹 Immutability and the `copy` method

Allows you to create a **modified copy** (immutability).

```kotlin
val p1 = Person("Ana", 30)
val p2 = p1.copy(age = 31)
```

---

## ⚙️ **CLASS DELEGATION (`by`)**

### 🔹 Composition over inheritance

Allows you to **delegate behaviors** to another class.

```kotlin
interface Logger {
fun log(msg: String)
}

class ConsoleLogger : Logger {
override fun log(msg: String) = println(msg)
}

class Service(private val logger: Logger) : Logger by logger

val service = Service(ConsoleLogger())
service.log("Startup") // delegates to ConsoleLogger
```

---

### 🔹 Dependency Injection

Allows you to inject different behavior without changing the class.

```kotlin
class FileLogger : Logger {
override fun log(msg: String) = println("Saving to file: $msg")
}

val service = Service(FileLogger()) // another implementation is injected
```

---

## 🧱 **THE `object` KEYWORD**

### 🔹 Object Declarations (Singleton)

**A single global instance is created**.

```kotlin
object Config {
var darkMode = true
}
```

---

### 🔹 Companion Object

Defines **static-like** members within a class.

```kotlin
class User(val name: String) {
companion object {
fun create(name: String) = User(name)
}
}

val u = User.create("David")
```

---

### 🔹 Object Expressions

Allow you to **create anonymous objects** (similar to anonymous classes in Java).

```kotlin
val listener = object : Runnable {
override fun run() = println("Running task")
}

listener.run()
```

> Useful for **implementing interfaces or extending classes without declaring them by name.**

---

# Activity 1 — Minimal `User` system (basic concepts of classes, properties, data classes, companions, visibility)

**Objective:** Practice `data classes`, constructors (primary + `init`), getters/setters with visibility control, and `companion objects`.

**What to create (files / classes):**

1. `User` data class with at least `id: String`, `name: String`, `email: String`, `age: Int`.

2. A `companion object` in `User` that provides a factory method to create users from name and email (e.g., generate `id` internally).

3. An `email` property with a `setter` that validates the basic format (e.g., contains `@`) — if it doesn't pass validation, the new value shouldn't be assigned.

4. An `age` property with a `private set` (external read-only, mutable within the class).

5. A primary constructor + `init` block that validates initial conditions (e.g., `age >= 0`), or throws an exception if they are not met.

**Step-by-step (what you have to do):**

- Design the `data class`, including the parameters you want to be part of the `equals`/`hashCode`.

- Implement a `companion object` with a `factory` (clear name) that allows you to create users without passing `id`.

- Implement `email` validation in the `setter` (use `field` to assign).

- Define `age` with appropriate visibility in the `setter` and ensure that `init` defines a valid value.

**Hints (no solution):**

- To validate in the `setter`, use the `field` backing field.

- `private set` is declared next to the property; consider when you want to be able to change `age`.

- `data class` autogenerates `copy()` — use it to clone a user with changes.

**Acceptance criteria / suggested tests:**

- Creating a user via the `factory` returns an object with a non-empty `id`.

- Attempting to assign an email without `@` does not change the email.

- `equals` between two users created with the same values ​​(except `id` if it is not part of the primary constructor) behaves as expected.

- `copy()` should allow the creation of a user variant with a different `age`.

**Optional Challenge:**
Make `User` immutable from the outside (all `val` properties), but allow `age` to be updated using a `cumplirAnios()` method that returns a new instance (use `copy()`).

---

# Activity 2 — Geometric Shape Hierarchy (inheritance, open/abstract, primary/secondary constructors, abstract properties)

**Objective:** Practice `open/abstract`, primary and secondary constructors, abstract and overriding properties, and base constructor calls.

**What to create:**

1. `Figure` abstract class with `area: Double` abstract property and `describe(): String` method (optional with default implementation using `area`).

2. Subclasses `Rectangle` and `Circle` that extend `Figure`.

- `Rectangle` with `base` and `height` and a primary constructor.

- `Circle` with `radius`. Add a secondary constructor that accepts diameter and delegates to the primary constructor.

3. `Shape` should use `init` for some common validation (e.g., dimensions > 0).

4. Use `open`/`final` where appropriate (consider whether you want someone to extend `Rectangle`).

**Step-by-step:**

- Declare `Shape` as `abstract` and define `area` as `abstract`.

- Implement `Rectangle` by calculating `area` from a property with `getter`.

- Implement `Circle` with a primary constructor and a secondary constructor that accepts diameter and calls the primary constructor.

- Make sure to call the base constructor appropriately (if `Shape` has parameters, pass them in inheritance).

**Tips:**

- For `area` in `Rectangle`, you can use `override`