## ðŸ§© **INTERFACES**

### ðŸ”¹ Abstract Members

These are **declarations without implementations**. Classes that implement the interface must define them.

```kotlin
interface Animal {
fun makeSound() // abstract
}

class Dog : Animal {
override fun makeSound() = println("Woof!")
}
```

---

### ðŸ”¹ Members with Default Implementation

An interface can have **methods implemented** (by default).

```kotlin
interface Animal {
fun sleep() {
println("Zzz...")
}
fun makeSound()
}

class Cat : Animal {
override fun makeSound() = println("Meow!")
}
```

> `Cat` directly inherits the implementation of `sleep()`.

---

### ðŸ”¹ Interface Implementation

A class can **implement multiple interfaces** at once.

```kotlin
interface A { fun foo() = println("A") }
interface B { fun foo() = println("B") }

class C : A, B {
override fun foo() {
super<A>.foo() // choose which one to call
super<B>.foo()
}
}
```

---

### ðŸ”¹ Sealed Interfaces

Sealed interfaces limit which classes can implement them (only within the same file).

```kotlin
sealed interface Result
class Success(val data: String) : Result
class Error(val message: String) : Result
```

> Very useful for handling states in `when` without needing `else`.

---

## ðŸ—ï¸ **CLASSES**

### ðŸ”¹ Primary constructor and `init` block

The **primary constructor** is defined along with the name, and `init` is executed when the object is created.

```kotlin
class Person(val name: String, val age: Int) {
init {
println("Creating person: $name, $age years")
}
}
```

---

### ðŸ”¹ Secondary constructors

They are used for **alternative initializations**.

```kotlin
class Person(val name: String) {
var age: Int = 0

constructor(name: String, age: Int) : this(name) {
this.age = age
}
}
```

---

### ðŸ”¹ Visibility Modifiers

They control **where members or classes can be accessed**:

- `public` (default)

- `internal` (only within the same module)

- `protected` (only in subclasses)

- `private` (only within the class)

```kotlin
class Example {
private val secret = "Hidden"
protected fun show() = println(secret)
}
```

---

## ðŸ’¡ **PROPERTIES**

### ðŸ”¹ Access to the backing field (`field`)

Used within Custom `getter` or `setter`.

```kotlin
class Counter {
var value: Int = 0
set(new) {
if (new >= 0) field = new // field = backing field
}
}
```

---

### ðŸ”¹ Change visibility of the getter or setter

You can **limit access** to the `set` or `get`.

```kotlin
class User {
var name: String = "Unknown"
private set // Can only be read externally, not modified
}
```

---

### ðŸ”¹ Abstract Properties

Declared in interfaces or abstract classes, with no implementation.

```kotlin
interface Shape {
val area: Double
}

class Circle(val radius: Double) : Shape {
override val area get() = Math.PI * radius * radius
}
```

---

### ðŸ”¹ Extension Properties

They allow **adding properties to existing classes** (they do not store actual state).

```kotlin
val String.vowels: Int
get() = count { it.lowercaseChar() in "aeiou" }

println("Kotlin".vowels) // 2
```

---

## ðŸ§¬ **INHERITANCE**

### ðŸ”¹ `open`, `final`, `abstract`

- `open`: can be inherited or overridden.

- `final`: cannot be inherited or overridden.

- `abstract`: must be implemented in subclasses.

```kotlin
open class Animal {
open fun sound() = println("Noise")
}

class Dog : Animal() {
override fun sound() = println("Woof!")
}
```

---

### ðŸ”¹ Call to the base (primary) constructor

```kotlin
open class Person(val name: String)
class Student(name: String, val grade: String) : Person(name)
```

---

### ðŸ”¹ Call to the base (secondary) constructor

```kotlin
open class Person(val name: String)
class Teacher : Person {
constructor(name: String, subject: String) : super(name)
}
```

---

### ðŸ”¹ Sealed classes

They control which subclasses can exist (in the same file).

```kotlin
sealed class Result
class Success(val data: String) : Result()
class Error(val msg: String) : Result()
```

---

## ðŸ§¾ **DATA CLASSES (`data class`)**

### ðŸ”¹ Autogenerated Methods

`data class` generates `toString()`, `equals()`, `hashCode()`, and `copy()` automatically.

```kotlin
data class Person(val name: String, val age: Int)

val p1 = Person("Ana", 30)
println(p1) // Person(name=Ana, age=30)
```

---

### ðŸ”¹ Immutability and the `copy` method

Allows you to create a **modified copy** (immutability).

```kotlin
val p1 = Person("Ana", 30)
val p2 = p1.copy(age = 31)
```

---

## âš™ï¸ **CLASS DELEGATION (`by`)**

### ðŸ”¹ Composition over inheritance

Allows you to **delegate behaviors** to another class.

```kotlin
interface Logger {
fun log(msg: String)
}

class ConsoleLogger : Logger {
override fun log(msg: String) = println(msg)
}

class Service(private val logger: Logger) : Logger by logger

val service = Service(ConsoleLogger())
service.log("Startup") // delegates to ConsoleLogger
```

---

### ðŸ”¹ Dependency Injection

Allows you to inject different behavior without changing the class.

```kotlin
class FileLogger : Logger {
override fun log(msg: String) = println("Saving to file: $msg")
}

val service = Service(FileLogger()) // another implementation is injected
```

---

## ðŸ§± **THE `object` KEYWORD**

### ðŸ”¹ Object Declarations (Singleton)

**A single global instance is created**.

```kotlin
object Config {
var darkMode = true
}
```

---

### ðŸ”¹ Companion Object

Defines **static-like** members within a class.

```kotlin
class User(val name: String) {
companion object {
fun create(name: String) = User(name)
}
}

val u = User.create("David")
```

---

### ðŸ”¹ Object Expressions

Allow you to **create anonymous objects** (similar to anonymous classes in Java).

```kotlin
val listener = object : Runnable {
override fun run() = println("Running task")
}

listener.run()
```

> Useful for **implementing interfaces or extending classes without declaring them by name.**

---

# Activity 1 â€” Minimal `User` system (basic concepts of classes, properties, data classes, companions, visibility)

**Objective:** Practice `data classes`, constructors (primary + `init`), getters/setters with visibility control, and `companion objects`.

**What to create (files / classes):**

1. `User` data class with at least `id: String`, `name: String`, `email: String`, `age: Int`.

2. A `companion object` in `User` that provides a factory method to create users from name and email (e.g., generate `id` internally).

3. An `email` property with a `setter` that validates the basic format (e.g., contains `@`) â€” if it doesn't pass validation, the new value shouldn't be assigned.

4. An `age` property with a `private set` (external read-only, mutable within the class).

5. A primary constructor + `init` block that validates initial conditions (e.g., `age >= 0`), or throws an exception if they are not met.

**Step-by-step (what you have to do):**

- Design the `data class`, including the parameters you want to be part of the `equals`/`hashCode`.

- Implement a `companion object` with a `factory` (clear name) that allows you to create users without passing `id`.

- Implement `email` validation in the `setter` (use `field` to assign).

- Define `age` with appropriate visibility in the `setter` and ensure that `init` defines a valid value.

**Hints (no solution):**

- To validate in the `setter`, use the `field` backing field.

- `private set` is declared next to the property; consider when you want to be able to change `age`.

- `data class` autogenerates `copy()` â€” use it to clone a user with changes.

**Acceptance criteria / suggested tests:**

- Creating a user via the `factory` returns an object with a non-empty `id`.

- Attempting to assign an email without `@` does not change the email.

- `equals` between two users created with the same values â€‹â€‹(except `id` if it is not part of the primary constructor) behaves as expected.

- `copy()` should allow the creation of a user variant with a different `age`.

**Optional Challenge:**
Make `User` immutable from the outside (all `val` properties), but allow `age` to be updated using a `cumplirAnios()` method that returns a new instance (use `copy()`).

---

# Activity 2 â€” Geometric Shape Hierarchy (inheritance, open/abstract, primary/secondary constructors, abstract properties)

**Objective:** Practice `open/abstract`, primary and secondary constructors, abstract and overriding properties, and base constructor calls.

**What to create:**

1. `Figure` abstract class with `area: Double` abstract property and `describe(): String` method (optional with default implementation using `area`).

2. Subclasses `Rectangle` and `Circle` that extend `Figure`.

- `Rectangle` with `base` and `height` and a primary constructor.

- `Circle` with `radius`. Add a secondary constructor that accepts diameter and delegates to the primary constructor.

3. `Shape` should use `init` for some common validation (e.g., dimensions > 0).

4. Use `open`/`final` where appropriate (consider whether you want someone to extend `Rectangle`).

**Step-by-step:**

- Declare `Shape` as `abstract` and define `area` as `abstract`.

- Implement `Rectangle` by calculating `area` from a property with `getter`.

- Implement `Circle` with a primary constructor and a secondary constructor that accepts diameter and calls the primary constructor.

- Make sure to call the base constructor appropriately (if `Shape` has parameters, pass them in inheritance).

**Tips:**

- For `area` in `Rectangle`, you can use `override`val area get() = base * height (computed property).

- Secondary constructor uses `:this(...)` to call the parent and `:super(...)` if `Shape` requires arguments.

**Acceptance criteria/tests:**

- Creating a `Rectangle(3.0, 4.0)` produces `area == 12.0`.

- Creating a `Circle` by radius and diameter produces identical areas.

- Attempting to create shapes with dimensions <= 0 throws an exception.

**Optional challenge:**
Mark `Rectangle` as `open` and create a `Square` subclass that reuses the rectangle logic.

---

# Activity 3 â€” Results with `sealed` (sealed classes/interfaces) and exhaustive `when`

**Objective:** Practice `sealed` (classes or interfaces), and use of `when` without `else`, and state representation.

**What to create:**

1. `sealed` class Result<out T>` with subclasses:

- `Success<T>(value: T)`

- `Error(message: String, code: Int = 0)`

- `Loading` (singleton object)

2. A set of functions that return `Result<T>` (simulates a call that may be loading, fail, or return data).

3. Use `when` to handle all three cases without `else` (ensure exhaustive compilation).

**Step-by-step:**

- Define the `sealed` hierarchy.

- Implement a function that simulates an operation (e.g., searching for a `User`) and returns `Success`, `Error`, or `Loading`.

- Consume the function and handle the result with an exhaustive `when` statement.

**Hints:**

- `Loading` can be an `object` (singleton).

- `when` in Kotlin is exhaustive with `sealed`, so you won't need an `else` statement if you cover all subclasses.

**Suggested Tests:**

- Mock each return and check that the corresponding `when` branch executes.

- Make sure that `when` doesn't require an `else` statement.

**Optional Challenge:**
Add a `SuccessWithGoal<T>(value: T, goal: Map<String, Any>)` type and update `when` to handle it.

---

# Activity 4 â€” Interfaces with Default Implementations and Conflicts (Multiple Interfaces)

**Objective:** Practice using default methods in interfaces and resolving conflicts using `super<Interface>.method()`.

**What to create:**

1. Two interfaces `A` and `B` with a `greeting()` method that have different default implementations.

2. Class `C` that implements both and chooses to call both implementations from its overridden `greeting()`.

3. Also add at least one abstract method in an interface that class `C` must implement.

**Step-by-Step:**

- Declare both interfaces with `fun greeting() { ... }`.

- Implement `C : A, B` and call `super<A>.greeting()` and `super<B>.greeting()` within the `override`. **Hints:**

- The `super<Interface>.method()` call is the way to specify the desired implementation.

**Suggested Tests:**

- Call `C().greet()` and verify (using output or spy) that both implementations were executed.

**Optional Challenge:**
Make one of the interfaces a `sealed interface` and define concrete types that implement it.

---

# Activity 5 â€” Delegation (`by`) and Logger Pattern with Injection (Composition over Inheritance)

**Objective:** Practice interface delegation, dependency injection, and use of `by`.

**What to create:**

1. `Logger { fun log(level: Level, msg: String) }` interface with an `enum class Level`.

2. Concrete implementations: `ConsoleLogger`, `FileLogger` (can simulate typing), and `NoOpLogger`.

3. A `Service` class that accepts a `Logger` in its constructor **and** delegates to `Logger` using `by logger`.

4. Alternatively, create a `ServiceWithLogs` class that *exposes* specific methods and internally uses delegation for logging functions.

**Step-by-Step:**

- Design the `Logger` interface.

- Implement at least two loggers with distinct behaviors.

- Create `Service(private val logger: Logger) : Logger by logger` and demonstrate that `Service` has the delegated `Logger` methods.

- Change the logger at runtime (if your design allows it) or create a factory for `Service` that injects the desired logger.

**Tips:**

- Delegation prevents you from writing `override fun log(...) = logger.log(...)` manually.

- For testing, inject `NoOpLogger` or a `Logger` that collects messages in memory.

**Suggested tests:**

- Instantiate `Service` with `ConsoleLogger`, observe the output.

- Replacing it with `NoOpLogger` should produce no output.

- Add tests that verify that the `Service` received logging calls (use a test implementation that accumulates messages).

**Optional challenge:**
Implement a `Logger` that filters by the minimum configured level (e.g., only `WARN` and `ERROR`).

---

# Activity 6 â€” `object` (singleton), `companion object`, anonymous object expressions

**Objective:** Practice `object` (singleton), `companion object` with factory methods and `object : Inter` expressionsface`.

**What to create:**

1. A singleton `Config` object containing a global configuration (e.g., `DebugMode: Boolean` and a `load()` function).

2. In the `User` data class (in Activity 1), use a `companion object` with a function that uses `Config` to decide how to generate the `id` (e.g., a `DEV-` prefix if `DebugMode == true`).

3. In one place, create an anonymous `object: Runnable { override fun run() = ... }` instance and use it to simulate a callback or listener.

**Step-by-Step:**

- Create `Config` as an `object`.

- Modify the `companion object` to read `Config` when generating data.

- Use an `object expression` to test an ad-hoc interface (e.g., `Comparator` or `Runnable`).

**Tips:**

- `object` is a singleton instance; you don't need `()` to access it.

- `companion object` can be named if you want a `companion object Factory`.

**Suggested Tests:**

- Change `Config.DebugMode` before creating a `User` to check if the generated `id` changes depending on the mode.

- Pass the `object expression` to a function that expects a `Runnable` and ensure it executes the code.

**Optional Challenge:**
Use `object` to implement a simple, globally accessible cache (in-memory map).

---

# Activity 7 â€” Advanced Properties and Extensions

**Objective:** Practice accessing the `field` in getter/setter, changing getter/setter visibility, abstract properties, and extension properties.

**What to create:**

1. `Account` class with `balance: Double` that:

- Has a `private set` on `balance`.

- `deposit` and `withdraw` methods that directly use `field` within a `setter` or securely update the balance.

2. Implement a custom `getter` that returns the formatted `balance` (e.g., with two decimal places or currency).

3. Create an extension property for `String`, e.g., `isEmailValid: Boolean` (`get` only), and use it in `User`.

4. Define an abstract property `description: String` in an interface and have `Account` implement it.

**Step-by-Step:**

- Declare the `balance` property with a `private set`.

- Implement logic to prevent negative balances.

- Define and use the extension property to validate emails.

**Tips:**

- To use `field`, you need a custom `getter` or `setter` on that same property.

- Extension properties cannot add storage (there is no `field`); their `getter` must calculate the value.

**Suggested Tests:**

- Deposit and withdraw with boundary conditions (withdrawing more than the balance).

- Validate that `isEmailValid` is `true` for valid basic emails.

**Optional Challenge:**
Implement a `delegated` property (e.g., `by lazy` or `Delegates.observable`) to store the last transaction date in `Account`.

---

# Activity 8 â€” Mini Integration Project (Uses Multiple Concepts)

**Objective:** Integrate interfaces, delegation, data classes, sealing, singletons, companions, inheritance, properties, and visibility into a small modular app.

**Project Description:**
Create a **mini-registration and session system** (CLI or small set of tests) that allows:

- Register users (`User` data class).

- Authenticate users (mock) by returning `Result` (`sealed`).

- Log actions in an injected `Logger` (uses `by` delegation).

- Maintain global configuration in `object Config`.

- Use `companion` for factories and `object expression` for quick handlers.

- A simple user repository that you can mock (injection with delegation), for example, `RepoUser` interface and `RepoUserInMemory class: RepoUser`.

**Minimum requirements (what it must do):**

1. `RepoUser` with functions: `save(user): Boolean`, `searchByEmail(email): User?`.

2. `AuthService` that depends on `RepoUser` and `Logger`, and that:

- Attempts to authenticate (fakes password or uses a simple property).

- Returns `Result` (`Success/Error/Loading`).

3. `App` that uses `Config` to decide whether to log operations, and that creates `AuthService` by passing it a `Logger` via DI.

4. Tests/executions that show:

- Successful logging.

- Successful and failed authentication.

- Logging according to `Config`.

**Step-by-step (suggested):**

- Design the interfaces and data classes.

- Implement `RepoUserInMemory` with an internal `MutableMap`.

- Implement `ConsoleLogger` and `NoOpLogger`.

- Implement `AuthService(private val repo: RepoUser, logger: Logger) : Logger by logger` (or similar).

- Create a `main` function or some tests that execute the cases.

**Minimum test cases to cover:**

- Registering a new user â†’ `save` returns `true`.

- Registering an existing user â†’ `save` returns `false`.

- Authenticate cwith correct credentials â†’ `Success`.

- Authenticate with incorrect credentials â†’ `Error`.

- Change `Config.DebugMode` and verify that the `Logger` is enabled/disabled as designed (if you apply that logic).

**Extras (challenges):**

- Add roles (using `sealed class Role` or `enum`) and control operation permissions.

- Implement "mock" persistence by exporting/importing JSON (without external libraries, serialize manually if you want).

- Implement unit tests for each component (repo, auth, logger).

---

# How to evaluate your work (quick checklist)

- Code compiles without errors.

- Each `data class` behaves as expected (test `copy`, `toString`).

- `when` on `sealed` is exhaustive (no `else`).

- Properties with validation use `field` and don't allow invalid states.

- `Setter`/`getter` have the appropriate visibility.

- `by` delegation works: the delegating class behaves like the implemented one.

- `object` and `companion` work and are used as intended.

- There are basic tests or executions that demonstrate core functionality.

---

# Workflow guide and best practices during activities

- Write small tests or `main` that create instances and verify results (print + simple assertions).

- Divide your code into files by responsibility (`models`, `services`, `repos`, `logging`).

- Use clear names for `companion objects` if there is more than one factory method.

- For debugging, implement a custom `toString()` if you need more detail.

- Start with interfaces and `data class` before implementing service logic; This way you can easily mock/inject dependencies.

---